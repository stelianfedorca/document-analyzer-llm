import { PDFDocument, StandardFonts, rgb } from "pdf-lib";
import { buildReportParts, type Props } from "./buildReportText";

const PAGE_WIDTH = 612;
const PAGE_HEIGHT = 792;
const PAGE_MARGIN = 54;
const HEADER_HEIGHT = 80;
const FOOTER_HEIGHT = 50;

const PRIMARY_COLOR = rgb(51 / 255, 65 / 255, 85 / 255); // Softer Medium Slate
const ACCENT_COLOR = rgb(59 / 255, 130 / 255, 246 / 255); // Lighter Branding Blue
const TEXT_HEADING = rgb(51 / 255, 65 / 255, 85 / 255);
const TEXT_BODY = rgb(71 / 255, 85 / 255, 105 / 255);
const MUTED_COLOR = rgb(148 / 255, 163 / 255, 184 / 255);

const TITLE_SIZE = 20;
const HEADING_SIZE = 14;
const BODY_SIZE = 11.5;
const LABEL_SIZE = 9.5;

const TITLE_LINE_HEIGHT = 24;
const HEADING_LINE_HEIGHT = 20;
const BODY_LINE_HEIGHT = 18;

function wrapText(
  text: string,
  font: { widthOfTextAtSize: (value: string, size: number) => number },
  size: number,
  maxWidth: number
) {
  const words = text.split(/\s+/).filter(Boolean);
  if (words.length === 0) return [""];

  const lines: string[] = [];
  let current = "";

  for (const word of words) {
    const candidate = current ? `${current} ${word}` : word;
    if (font.widthOfTextAtSize(candidate, size) <= maxWidth) {
      current = candidate;
      continue;
    }

    if (current) lines.push(current);

    if (font.widthOfTextAtSize(word, size) <= maxWidth) {
      current = word;
      continue;
    }

    const broken = breakLongWord(word, font, size, maxWidth);
    lines.push(...broken.slice(0, -1));
    current = broken[broken.length - 1] ?? "";
  }

  if (current) lines.push(current);

  return lines;
}

function breakLongWord(
  word: string,
  font: { widthOfTextAtSize: (value: string, size: number) => number },
  size: number,
  maxWidth: number
) {
  const chars = [...word];
  const pieces: string[] = [];
  let current = "";

  for (const char of chars) {
    const candidate = `${current}${char}`;
    if (font.widthOfTextAtSize(candidate, size) <= maxWidth) {
      current = candidate;
      continue;
    }

    if (current) pieces.push(current);
    current = char;
  }

  if (current) pieces.push(current);

  return pieces;
}

export async function buildReportPdf(props: Props) {
  const pdfDoc = await PDFDocument.create();
  const fontRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const { title, docTypeLabel, formattedDate, fileName, mainPoints, summary } =
    buildReportParts(props);

  let pages = [pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT])];
  let currentPageIndex = 0;
  let y = PAGE_HEIGHT - HEADER_HEIGHT;
  const maxWidth = PAGE_WIDTH - PAGE_MARGIN * 2;

  const getCurrentPage = () => pages[currentPageIndex];

  const newPage = () => {
    const page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    pages.push(page);
    currentPageIndex++;
    y = PAGE_HEIGHT - HEADER_HEIGHT;
  };

  const ensureSpace = (needed: number) => {
    if (y < PAGE_MARGIN + FOOTER_HEIGHT + needed) {
      newPage();
    }
  };

  const drawHeader = (page: any) => {
    const headerY = PAGE_HEIGHT - 35;

    // Logo / Brand
    page.drawText("DocuSense", {
      x: PAGE_MARGIN,
      y: headerY,
      size: 13,
      font: fontBold,
      color: ACCENT_COLOR,
    });

    const rightHeaderText = "Document Analysis Report";
    const rightHeaderWidth = fontRegular.widthOfTextAtSize(rightHeaderText, 10);
    page.drawText(rightHeaderText, {
      x: PAGE_WIDTH - PAGE_MARGIN - rightHeaderWidth,
      y: headerY,
      size: 10,
      font: fontRegular,
      color: MUTED_COLOR,
    });

    // Divider
    page.drawLine({
      start: { x: PAGE_MARGIN, y: PAGE_HEIGHT - 50 },
      end: { x: PAGE_WIDTH - PAGE_MARGIN, y: PAGE_HEIGHT - 50 },
      thickness: 0.5,
      color: MUTED_COLOR,
      opacity: 0.2,
    });
  };

  const drawFooter = (page: any, index: number, total: number) => {
    const footerY = 25;
    const pageText = `Page ${index + 1} of ${total}`;
    const pageTextWidth = fontRegular.widthOfTextAtSize(pageText, 9);

    page.drawText(pageText, {
      x: PAGE_WIDTH - PAGE_MARGIN - pageTextWidth,
      y: footerY,
      size: 9,
      font: fontRegular,
      color: MUTED_COLOR,
    });

    page.drawText("Generated by DocuSense AI", {
      x: PAGE_MARGIN,
      y: footerY,
      size: 9,
      font: fontRegular,
      color: MUTED_COLOR,
    });
  };

  const drawWrappedText = (
    text: string,
    font: typeof fontRegular,
    size: number,
    lineHeight: number,
    color = TEXT_BODY,
    indent = 0
  ) => {
    const lines = wrapText(text, font, size, maxWidth - indent);
    for (const line of lines) {
      ensureSpace(lineHeight);
      getCurrentPage().drawText(line, {
        x: PAGE_MARGIN + indent,
        y,
        size,
        font,
        color,
      });
      y -= lineHeight;
    }
  };

  // --- Title Section ---
  y -= 20;
  drawWrappedText(
    title,
    fontBold,
    TITLE_SIZE,
    TITLE_LINE_HEIGHT,
    PRIMARY_COLOR
  );
  y -= 15;

  // --- Metadata Section (Vertical Stack) ---
  // --- Metadata Section ---
  const metadataItems = [
    { label: "SOURCE FILE", value: fileName },
    { label: "DOCUMENT TYPE", value: docTypeLabel?.toUpperCase() },
    { label: "DATE ANALYZED", value: formattedDate?.toUpperCase() },
  ].filter((item) => item.value);

  if (metadataItems.length > 0) {
    const sectionPaddingV = 16;
    const sectionPaddingH = 16;
    const itemGap = 22; // Consistent gap between items
    const lineGap = 16; // Gap between lines of the same multi-line item

    const labelFontSize = LABEL_SIZE;
    const maxLabelWidth = Math.max(
      ...metadataItems.map((item) =>
        fontBold.widthOfTextAtSize(`${item.label}:`, labelFontSize)
      )
    );
    // Dynamic label width: Padding + Bar Offset + Label Width + Requested "more space" gap
    const labelColumnWidth = sectionPaddingH + 4 + maxLabelWidth + 30;

    // Pre-calculate segments and total height to ensure section fits together
    const itemsWithLines = metadataItems.map((item) => ({
      ...item,
      lines: wrapText(
        item.value!,
        fontRegular,
        BODY_SIZE - 1.5,
        maxWidth - labelColumnWidth - sectionPaddingH
      ),
    }));

    const totalTextLines = itemsWithLines.reduce(
      (acc, item) => acc + item.lines.length,
      0
    );
    // totalHeight = top/bottom padding + all line heights + extra gaps between different items
    const sectionHeight =
      sectionPaddingV * 2 +
      totalTextLines * lineGap +
      (itemsWithLines.length - 1) * (itemGap - lineGap);

    ensureSpace(sectionHeight + 20);

    const startY = y;
    const rectY = y - sectionHeight;

    // Draw background (subtle light blue/slate)
    getCurrentPage().drawRectangle({
      x: PAGE_MARGIN,
      y: rectY,
      width: maxWidth,
      height: sectionHeight,
      color: rgb(249 / 255, 251 / 255, 254 / 255),
    });

    // Draw vertical bar (color same as labels/text)
    getCurrentPage().drawRectangle({
      x: PAGE_MARGIN,
      y: rectY,
      width: 3,
      height: sectionHeight,
      color: TEXT_HEADING,
    });

    let currentY = startY - sectionPaddingV - 10; // Initial text baseline

    itemsWithLines.forEach((item) => {
      const labelText = `${item.label}:`;
      // Draw Label
      getCurrentPage().drawText(labelText, {
        x: PAGE_MARGIN + sectionPaddingH + 4,
        y: currentY,
        size: labelFontSize,
        font: fontBold,
        color: TEXT_HEADING,
      });

      // Draw Value lines (perfectly aligned with labelColumnWidth)
      item.lines.forEach((line) => {
        getCurrentPage().drawText(line, {
          x: PAGE_MARGIN + labelColumnWidth,
          y: currentY,
          size: BODY_SIZE - 1.5,
          font: fontRegular,
          color: TEXT_HEADING,
        });
        currentY -= lineGap;
      });

      // Advance to next item with extra spacing
      currentY -= itemGap - lineGap;
    });

    y = rectY - 40;
  }

  // --- Main Points Section ---
  drawWrappedText(
    "Key Findings",
    fontBold,
    HEADING_SIZE,
    HEADING_LINE_HEIGHT,
    PRIMARY_COLOR
  );
  y -= 12;

  const pointItems =
    mainPoints.length > 0 ? mainPoints : ["(No main points available)"];
  for (const point of pointItems) {
    const bullet = "â€¢";
    const bulletWidth = 20;
    const lines = wrapText(
      point,
      fontRegular,
      BODY_SIZE,
      maxWidth - bulletWidth
    );

    ensureSpace(BODY_LINE_HEIGHT * lines.length);

    lines.forEach((line, index) => {
      if (index === 0) {
        getCurrentPage().drawText(bullet, {
          x: PAGE_MARGIN + 5,
          y,
          size: BODY_SIZE + 2,
          font: fontBold,
          color: ACCENT_COLOR, // Subtle blue highlight for bullets
        });
      }
      getCurrentPage().drawText(line, {
        x: PAGE_MARGIN + bulletWidth,
        y,
        size: BODY_SIZE,
        font: fontRegular,
        color: TEXT_BODY,
      });
      y -= BODY_LINE_HEIGHT;
    });
    y -= 10;
  }

  y -= 25;

  // --- Summary Section ---
  drawWrappedText(
    "Overview",
    fontBold,
    HEADING_SIZE,
    HEADING_LINE_HEIGHT,
    PRIMARY_COLOR
  );
  y -= 12;

  const summaryItems =
    summary.length > 0 ? summary : ["(No summary available)"];
  for (const paragraph of summaryItems) {
    drawWrappedText(
      paragraph,
      fontRegular,
      BODY_SIZE,
      BODY_LINE_HEIGHT,
      TEXT_BODY
    );
    y -= 12;
  }

  // --- Final Touches: Headers and Footers ---
  const totalPages = pages.length;
  pages.forEach((page, index) => {
    drawHeader(page);
    drawFooter(page, index, totalPages);
  });

  return pdfDoc.save();
}
